using System;
using System.IO;
using System.Threading;
using System.Threading.Tasks;
using Newtonsoft.Json.Linq;

public enum SourceType
{
    Media,
    Image,
    TextFile,
    Text
}

public class FontSettings
{
    public string Family { get; set; }
    public int Size { get; set; }
    public int Color { get; set; }
    public string Style { get; set; }
    public int BgColor { get; set; }
    public int BgOpacity { get; set; }
    public bool EnableBg { get; set; }

    public FontSettings(string family, int size, int color, string style, int bgColor, int bgOpacity, bool enableBg)
    {
        Family = family;
        Size = size;
        Color = color;
        Style = style;
        BgColor = bgColor;
        BgOpacity = bgOpacity;
        EnableBg = enableBg;
    }
}

public class CPHInline
{
    private T TryGetArg<T>(string argName, T defaultValue)
    {
        if (CPH.TryGetArg(argName, out object raw))
        {
            try
            {
                if (typeof(T) == typeof(int) && raw is string s)
                {
                    // Handle hex like "0xFFFFFF"
                    if (s.StartsWith("0x", StringComparison.OrdinalIgnoreCase))
                    {
                        int hex = int.Parse(s.Substring(2), System.Globalization.NumberStyles.HexNumber);
                        return (T)(object)hex;
                    }
                }
                return (T)Convert.ChangeType(raw, typeof(T));
            }
            catch
            {
                return defaultValue;
            }
        }
        return defaultValue;
    }

    public bool Execute()
    {
        //BlinkVidPath is an old parameter name kept for backward compatibility
        string content      = TryGetArg<string>( "BlinkVidPath", @"" );
        if( string.IsNullOrWhiteSpace( content ) )
            content         = TryGetArg<string>( "BlinkContent", @"" );

        int taskLength      = TryGetArg<int>( "BlinkTaskLength", 10 ); // seconds
        int chroma          = TryGetArg<int>( "BlinkChroma", -1 );
        int width           = TryGetArg<int>( "BlinkWidth", 640 );
        int height          = TryGetArg<int>( "BlinkHeight", 360 );
        int posX            = TryGetArg<int>( "BlinkPosX", 100 );
        int posY            = TryGetArg<int>( "BlinkPosY", 100 );
        int similarity      = TryGetArg<int>( "BlinkChromaSim", 400 );
        int smoothness      = TryGetArg<int>( "BlinkChromaSmooth", 80 );
        bool MonitorAudio   = TryGetArg<bool>( "BlinkAudioMonitor", false );
        string forceType    = TryGetArg<string>( "BlinkForceType", "" );
        
        // Font settings
        var fontSettings = new FontSettings(
            TryGetArg<string>( "BlinkFontFamily", "Arial" ),
            TryGetArg<int>( "BlinkFontSize", 48 ),
            TryGetArg<int>( "BlinkTextColor", 0xFFFFFF ),
            TryGetArg<string>( "BlinkFontStyle", "" ),
            TryGetArg<int>( "BlinkBgColor", 0x000000 ),
            TryGetArg<int>( "BlinkBgOpacity", 0 ),
            TryGetArg<bool>( "BlinkEnableBg", false )
        );

        string sceneName = CPH.ObsGetCurrentScene();
        var task = new ObsMediaTask(sceneName, content, taskLength, chroma,
                                    width, height, posX, posY,
                                    similarity, smoothness, MonitorAudio, forceType,
                                    fontSettings, this);
        task.Start();

        return true;
    }
}

public class ObsMediaTask
{
    private readonly string sceneName;
    private readonly string content;
    private readonly int taskLength;
    private readonly CPHInline Parent;
    private readonly string sourceName;
    private readonly int chromaKey;
    private readonly int width;
    private readonly int height;
    private readonly int posX;
    private readonly int posY;
    private readonly int similarity;
    private readonly int smoothness;
    private readonly bool AudioMonitor;
    private readonly SourceType sourceType;
    private readonly FontSettings fontSettings;

    private int sceneItemId;

    public ObsMediaTask(string sceneName, string content, int taskLength, int chromaKey,
                        int width, int height, int posX, int posY,
                        int similarity, int smoothness, bool monitorAudio, string forceType,
                        FontSettings fontSettings, CPHInline parent)
    {
        this.sceneName    = sceneName;
        this.content      = content.Replace("\\", "/");
        this.taskLength   = taskLength;
        this.sourceName   = "Task_" + Guid.NewGuid().ToString("N").Substring(0, 6);
        this.chromaKey    = chromaKey;
        this.width        = width;
        this.height       = height;
        this.posX         = posX;
        this.posY         = posY;
        this.similarity   = similarity;
        this.smoothness   = smoothness;
        this.AudioMonitor = monitorAudio;
        this.fontSettings = fontSettings;
        this.Parent       = parent;

        // Determine source type based on this.content with optional override
        this.sourceType = DetermineSourceType(this.content, forceType);
        Parent.CPH.LogInfo($"Determined source type: {sourceType} for path: {this.content}");

        //if provided was a file, but no file found then just force it to be text...
        if ( ( this.sourceType != SourceType.Text ) && ( !File.Exists( this.content ) ) )
        {
            Parent.CPH.LogError($"File not found: {this.content}");
            this.sourceType = SourceType.Text;
        }

        AddSource();
        if( chromaKey >= 0 )
            AddFilter();
        if( AudioMonitor && sourceType == SourceType.Media )
            AddMonitor();
        SetTransform();
    }

    public void Start()
    {
        Task.Run(async () =>
        {
            Parent.CPH.LogInfo($"Task started for {taskLength}s on source {sourceName}");
            await Task.Delay(taskLength * 1000);
            RemoveSource();
            Parent.CPH.LogInfo($"Task finished, source {sourceName} removed.");
        });
    }

    private SourceType DetermineSourceType(string path, string forceType)
    {
        // Check for force type override first
        if (!string.IsNullOrWhiteSpace(forceType))
        {
            switch (forceType.ToLowerInvariant())
            {
                case "media":
                case "video":
                    Parent.CPH.LogInfo($"Force override: Using Media source type");
                    return SourceType.Media;
                case "image":
                case "img":
                    Parent.CPH.LogInfo($"Force override: Using Image source type");
                    return SourceType.Image;
                case "textfile":
                case "text_file":
                case "file":
                    Parent.CPH.LogInfo($"Force override: Using TextFile source type");
                    return SourceType.TextFile;
                case "text":
                case "string":
                    Parent.CPH.LogInfo($"Force override: Using Text source type");
                    return SourceType.Text;
                default:
                    Parent.CPH.LogWarn($"Unknown force type '{forceType}', falling back to auto-detection");
                    break;
            }
        }

        // Auto-detect based on extension
        string extension = Path.GetExtension(path).ToLowerInvariant();
        
        // Video extensions
        string[] videoExtensions = { ".mp4", ".avi", ".mov", ".mkv", ".wmv", ".flv", ".webm", ".m4v", ".3gp", ".mpg", ".mpeg" };
        
        // Image extensions  
        string[] imageExtensions = { ".jpg", ".jpeg", ".png", ".gif", ".bmp", ".tiff", ".tga", ".webp" };
        
        // Text file extensions
        string[] textExtensions = { ".txt", ".rtf", ".log", ".md", ".json", ".xml", ".csv" };
        
        if (Array.Exists(videoExtensions, ext => ext == extension))
        {
            return SourceType.Media;
        }
        else if (Array.Exists(imageExtensions, ext => ext == extension))
        {
            return SourceType.Image;
        }
        else if (Array.Exists(textExtensions, ext => ext == extension))
        {
            return SourceType.TextFile;
        }
        else
        {
            return SourceType.Text;
        }
    }

    private void AddSource()
    {
        switch (sourceType)
        {
            case SourceType.Media:
                Parent.CPH.LogInfo($"Creating media source for: {this.content}");
                AddMediaSource();
                break;
            case SourceType.Image:
                Parent.CPH.LogInfo($"Creating image source for: {this.content}");
                AddImageSource(this.content);
                break;
            case SourceType.TextFile:
                Parent.CPH.LogInfo($"Creating text source from file: {this.content}");
                AddTextSourceFromFile(this.content, fontSettings);
                break;
            case SourceType.Text:
                Parent.CPH.LogInfo($"Creating text source with this.content: {this.content}");
                AddTextSource(this.content, fontSettings);
                break;
            default:
                Parent.CPH.LogError($"Unknown source type: {sourceType}");
                break;
        }
    }

    private void AddMediaSource()
    {
        string createInputJson = $@"{{
            ""sceneName"": ""{sceneName}"",
            ""inputName"": ""{sourceName}"",
            ""inputKind"": ""ffmpeg_source"",
            ""inputSettings"": {{
                ""local_file"": ""{this.content}"",
                ""is_local_file"": true,
                ""looping"": true
            }},
            ""sceneItemEnabled"": true
        }}";
        string resp = Parent.CPH.ObsSendRaw("CreateInput", createInputJson);
        var obj = JObject.Parse(resp);
        var idToken = obj["sceneItemId"];
        if (idToken != null)
            sceneItemId = (int)idToken;
        else
            Parent.CPH.LogError("Failed to parse sceneItemId from CreateInput response.");
    }

    private void AddImageSource(string imagePath)
    {
        string createInputJson = $@"{{
            ""sceneName"": ""{sceneName}"",
            ""inputName"": ""{sourceName}"",
            ""inputKind"": ""image_source"",
            ""inputSettings"": {{
                ""file"": ""{imagePath.Replace("\\", "/")}"",
                ""unload"": false
            }},
            ""sceneItemEnabled"": true
        }}";
        string resp = Parent.CPH.ObsSendRaw("CreateInput", createInputJson);
        var obj = JObject.Parse(resp);
        var idToken = obj["sceneItemId"];
        if (idToken != null)
            sceneItemId = (int)idToken;
        else
            Parent.CPH.LogError("Failed to parse sceneItemId from CreateInput response.");
    }

    private void AddTextSourceFromFile(string textFilePath, FontSettings font)
    {
        var payload = new JObject {
            ["sceneName"] = sceneName,
            ["inputName"] = sourceName,
            ["inputKind"] = "text_gdiplus_v3",
            ["inputSettings"] = new JObject{
                ["read_from_file"] = true,
                ["file"] = textFilePath.Replace("\\", "/"),
                ["color"] = font.Color, // text color
                ["font_color"] = font.Color, // text color
                ["bk_color"] = font.BgColor, // background color
                ["bk_opacity"] = font.BgOpacity, // background opacity
                ["alignment"] = 1, // center text vertically
                ["font_size"] = font.Size,
                ["background"] = font.EnableBg,
                ["wrap"] = true,
                ["font"] = new JObject {
                    ["face"] = font.Family,
                    ["style"] = font.Style,
                    ["color"] = font.Color,
                    ["flags"] = 0, // no special flags
                    ["size"] = font.Size,
                }
            },
            ["sceneItemEnabled"] = true
        };
        
        string resp = Parent.CPH.ObsSendRaw("CreateInput", payload.ToString());
        var obj = JObject.Parse(resp);
        var idToken = obj["sceneItemId"];
        if (idToken != null)
            sceneItemId = (int)idToken;
        else
            Parent.CPH.LogError("Failed to parse sceneItemId from CreateInput response.");
    }
    private void AddTextSource(string text, FontSettings font)
    {
        var payload = new JObject {
            ["sceneName"] = sceneName,
            ["inputName"] = sourceName,
            ["inputKind"] = "text_gdiplus_v3",
            ["inputSettings"] = new JObject{
                ["text"] = text,
                ["color"] = font.Color, // text color
                ["font_color"] = font.Color, // text color
                ["bk_color"] = font.BgColor, // background color
                ["bk_opacity"] = font.BgOpacity, // background opacity
                ["alignment"] = 1, // center text vertically
                ["font_size"] = font.Size,
                ["background"] = font.EnableBg,
                ["wrap"] = true,
                ["font"] = new JObject {
                    ["face"] = font.Family,
                    ["style"] = font.Style,
                    ["color"] = font.Color,
                    ["flags"] = 0, // no special flags
                    ["size"] = font.Size,
                }
            },
            ["sceneItemEnabled"] = true
        };
        
        string resp = Parent.CPH.ObsSendRaw("CreateInput", payload.ToString());
        var obj = JObject.Parse(resp);
        var idToken = obj["sceneItemId"];
        if (idToken != null)
            sceneItemId = (int)idToken;
        else
            Parent.CPH.LogError("Failed to parse sceneItemId from CreateInput response.");
    }

    private void AddFilter()
    {
        Parent.CPH.ObsSendRaw("CreateSourceFilter", $@"{{
            ""sourceName"": ""{sourceName}"",
            ""filterName"": ""Chroma Key"",
            ""filterKind"": ""chroma_key_filter""
        }}");

        Parent.CPH.ObsSendRaw("SetSourceFilterSettings", $@"{{
            ""sourceName"": ""{sourceName}"",
            ""filterName"": ""Chroma Key"",
            ""filterSettings"": {{
                ""key_color_type"": ""custom"",
                ""key_color"": {chromaKey},
                ""similarity"": {similarity},
                ""smoothness"": {smoothness},
                ""spill"": 0
            }}
        }}");
    }

    private void SetTransform()
    {
        if (sceneItemId == 0) return;

        var (nativeW, nativeH) = GetValidBox(sceneName, sceneItemId);
        if (nativeW == 0 || nativeH == 0)
        {
            nativeW = 1;
            nativeH = 1;
            Parent.CPH.LogError("Could not get native size.");
        }

        double scaleX = (double)width / nativeW;
        double scaleY = (double)height / nativeH;

        string transformJson = $@"{{
            ""sceneName"": ""{sceneName}"",
            ""sceneItemId"": {sceneItemId},
            ""sceneItemTransform"": {{
                ""positionX"": {posX},
                ""positionY"": {posY},
                ""alignment"": 1,
                ""scaleX"": {scaleX.ToString(System.Globalization.CultureInfo.InvariantCulture)},
                ""scaleY"": {scaleY.ToString(System.Globalization.CultureInfo.InvariantCulture)}
            }}
        }}";
        Parent.CPH.ObsSendRaw("SetSceneItemTransform", transformJson);
    }

    private (double w, double h) GetValidBox(string sceneName, int sceneItemId)
    {
        for (int attempt = 0; attempt < 5; attempt++)
        {
            string req = $@"{{ ""sceneName"": ""{sceneName}"", ""sceneItemId"": {sceneItemId} }}";
            string resp = Parent.CPH.ObsSendRaw("GetSceneItemTransform", req);
            var obj = JObject.Parse(resp);
            var tr = obj["sceneItemTransform"] ?? obj["responseData"]?["sceneItemTransform"];
            if (tr != null)
            {
                double w = ToDouble(tr["width"]);
                double h = ToDouble(tr["height"]);
                if (w > 0 && h > 0) return (w, h);
            }
            Thread.Sleep(50); // small wait before retry
        }
        return (0, 0); // fallback
    }

    private static double ToDouble(JToken token)
    {
        if (token == null) return 0;
        if (token.Type == JTokenType.Float || token.Type == JTokenType.Integer) return (double)token;

        double.TryParse(
            token.ToString(),
            System.Globalization.NumberStyles.Any,
            System.Globalization.CultureInfo.InvariantCulture,
            out double v
        );
        return v;
    }

    private void AddMonitor()
    {
        Parent.CPH.ObsSendRaw("SetInputAudioMonitorType", $@"{{
            ""inputName"": ""{sourceName}"",
            ""monitorType"": ""OBS_MONITORING_TYPE_MONITOR_AND_OUTPUT""
        }}");
    }

    private void RemoveSource()
    {
        Parent.CPH.ObsSendRaw("RemoveInput", $@"{{ ""inputName"": ""{sourceName}"" }}");
    }
}
